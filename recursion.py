"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, Alexandru Aghinitei and <FULL NAME>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: asa3964
UT EID 2:
"""


def group_sum(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if target == 0:
        return True
    if start >= len(nums):
        return False
    
    #Backtrack with include and exclude
    return group_sum(start+1, nums, target-nums[start]) or group_sum(start+1,nums,target)
    
    


def group_sum_6(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target. Additionally, if there is are 6's present in the array, they must all
    be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if target == 0:
        return True
    if start >= len(nums):
        return False
    
    # ensures that 6 is used
    if nums[start] == 6:
        return group_sum_6(start+1,nums,target-nums[start])
    else:
    #Backtrack with include and exclude
        return group_sum_6(start+1, nums, target-nums[start]) or group_sum_6(start+1,nums,target)
    
    


def group_no_adj(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a value is chosen, the value immediately after
    (the value adjacent) cannot be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    
    if target == 0:
        return True
    if start >= len(nums):
        return False
    
    #Backtrack with icnlude with start + 2 and exclude
    return group_no_adj(start+2, nums, target-nums[start]) or group_no_adj(start+1,nums,target)


def group_sum_5(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a multiple of 5 is in the array, it must be included
    If the value immediately following a multiple of 5 if 1, it must not be chosen

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if target == 0:
        return True
    if start >= len(nums):
        return False
    
    # ensures that 5 multiple is used and it skips it only if the number following is 1, otherwise no skip
    if nums[start] %5 == 0:
        if start + 1 < len(nums) and nums[start+1] == 1:
            return group_sum_5(start+2,nums,target-nums[start])
        else:
            return group_sum_5(start+1,nums,target-nums[start])
    else:
    #Backtrack with include and exclude
        return group_sum_5(start+1, nums, target-nums[start]) or group_sum_5(start+1,nums,target)


def group_sum_clump(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if there is a group of identical numbers in succession,
    they must all be chosen, or none of them must be chosen.
    EX: [1, 2, 2, 2, 5, 2], all three of the middle 2's must be chosen, or none of them must be
    chosen to be included in the sum. One loop is allowed to check for identical numbers.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if target == 0:
        return True
    if start >= len(nums):
        return False
    
    #counter will already be at 1 if second statement holds true
    counter = 1
    while (start+counter)<len(nums) and (nums[start] == nums[start+counter]):
        counter+=1
        
    # backtrack w include the clump sum - (counter * num) or exclude
    return group_sum_clump(start+counter, nums, target - counter * nums[start]) or group_sum_clump(start + counter, nums, target)
    


def split_array(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    
    # sum of both halves
    target = sum(nums) // 2
    start = 0 
    return split_array_helper(start,nums,target)
    
def split_array_helper(start, nums,target):
    """
    basically does what the group_sum function does, sees
    if there is a subset that would add up to the target,
    sums//2, and we only have to check once because we know the
    other subset must also add up to sums//2
    """
    if target == 0:
        return True
    if start >= len(nums):
        return False
    
    #Backtrack with include and exclude
    return split_array_helper(start+1, nums, target-nums[start]) or split_array_helper(start+1,nums,target)
        


def split_odd_10(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of one group must be odd, while the other group must be a multiple of 10
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    return split_odd_10_helper(0,nums,0,0)

def split_odd_10_helper(start, nums, target1, target2):
    """
    have to do it a little different, instead of subtracting and seeing if base is 0,
    need to actually add them up to see if their final sums match odd and mod 10, which 
    you cant do if you are subtracting from it and the final sums equal 0
    """
    # checks the odd and mod 10, but also checks if the list has been fully explored with start >= len(nums)
    if start >= len(nums):
        if (target1 % 10 == 0 and target2 % 2 == 1) or (target1 % 2 == 1 and target2 % 10 == 0):
            return True
        else:
            return False
    
    # does one where the sum is added to target 1, and the other where its added to target 2, "back tracking" between both possibilities.
    return split_odd_10_helper(start+1,nums,target1+nums[start],target2) or split_odd_10_helper(start+1,nums,target1,target2+nums[start])
    


def split_53(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Additionally, all multiples of 5 must be in one group, and all multiples of 3 (and not 5)
    must be in the other group
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    return split_53_helper(0,nums,0,0)

def split_53_helper(start, nums, target1, target2):
    """
    basically follows the logic of both split odd 10 and group sum 5, where it checks if its %5 or %3, and
    does a recursive call from there, and if its neither, it does a generic backtracking recursive call for
    an non 5 or 3 multiple
    """
    # checks if target is mod 3 or mod 5, but also checks if the list has been fully explored with start >= len(nums)
    if start >= len(nums):
        if target1 == target2:
            return True
        else:
            return False
                
    if nums[start] % 5 == 0:
        return split_53_helper(start+1,nums,target1+nums[start],target2) or split_53_helper(start+1,nums,target1,target2+nums[start])
    
    elif nums[start] % 3 == 0:
        return split_53_helper(start+1,nums,target1+nums[start],target2) or split_53_helper(start+1,nums,target1,target2+nums[start])
    
    else:
        return split_53_helper(start+1,nums,target1+nums[start],target2) or split_53_helper(start+1,nums,target1,target2+nums[start])

    